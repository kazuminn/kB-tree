const std = @import("std");
const heap = std.heap;
const ok = std.testing.ok;

const Root = struct {
    root : *Btree,
};

const Btree = struct {
    const Self = @This();

    child_ptr: []*Btree,
    has_number: u32,
    element: []i64,
    leaf: bool,
    t: u8,

    pub fn new() Self {
        var allocator = heap.c_allocator;
        var child_ptr = heap.alloc(allocator, *Btree, 4) catch |err| { 
                            std.debug.panic("can not alloc");
                        };
        return Self{
            .child_ptr = child_ptr,
            .has_number = 0,
            .element = undefined, 
            .leaf = true,
            .t = 2,
        };
    }

    pub fn allocNode() Self {
        var node = Btree.new();
        var element = [_]i64{0, 0, 0};
        node.element = element[0..3];
        return node;
    }

    pub fn splitChild(x: *Btree, i: usize) void {
        var z = allocNode();
        var y = x.child_ptr[i];
        z.leaf = y.leaf;
        var j: u32 = 0;
        while (j < x.t - 1) : (j += 1) {
            z.element[j] = y.element[j + x.t];
        }
        if (!y.leaf) {
            j = 1;
            while (j < x.t) : (j += 1) {
                z.child_ptr[j] = y.child_ptr[j + x.t];
            }
        }
        y.has_number -= 1;
        j = x.has_number + 1;
        while (j > i + 1) : (j -= 1) {
            x.child_ptr[j + 1] = x.child_ptr[j];
        }
        x.child_ptr[i + 1] = &z;
        j = x.has_number;
        while (j > i) : (j -= 1) {
            x.element[j + 1] = x.element[j];
        }
        x.element[i] = y.element[x.t- 1];
        x.has_number +=  1;
    }

    pub fn insertNonFull(x: *Btree, insert_element: i64) void {
        var i: usize = x.has_number;
        if (x.leaf) {
            while (i >= 1 and insert_element < x.element[i - 1]) : (i -= 1) {
                x.element[i] = x.element[i - 1];
            }
            x.element[i] = insert_element;
            std.debug.warn("{} \n", x.element[i]);
            x.has_number += 1;
        } else {
            while (i >= 1 and insert_element < x.element[i]) : (i -= 1) {}
            i += 1;
            var y: *Btree = x.child_ptr[i];
            if (y.has_number == 2 * x.t - 1) {
                splitChild(y, i);
                if (insert_element > y.element[i]) {
                    i += 1;
                }
            }
            insertNonFull(y, insert_element);
        }
    }

    pub fn insert(self: Self, insert_element: i64, T: *Root) void {
        var r = T.root;
        if (r.has_number == 2 * r.t - 1) { 
            var s = allocNode();
            T.root = &s;
            s.leaf = false;
            s.child_ptr[0] = r;
            splitChild(&s, 0);
            insertNonFull(&s, insert_element);
        } else {
            insertNonFull(r, insert_element);
        }
    }
};

pub fn main() anyerror!void {
    var T : Root = undefined;
    T.root = &Btree.allocNode(); // create root
    T.root.insert(1, &T);
    T.root.insert(2, &T);
    T.root.insert(3, &T);
    std.debug.warn("{} \n", T.root.element[0]);
    std.debug.warn("{} \n", T.root.element[1]);
    std.debug.warn("{} \n", T.root.element[2]);
    //std.debug.warn("{} \n", T.root.child_ptr[0]);
}

test "root node" {
    var T : Root = undefined;
    T.root = &Btree.allocNode(); // create root
    T.root.insert(1, &T);
    T.root.insert(2, &T);
    ok(T.root.element[0] == 1);
    ok(T.root.element[1] == 2);
}
