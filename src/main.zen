const std = @import("std");

const Btree = struct {
    const Self = @This();

    child_ptr: []*Btree,
    has_number: u32,
    element : []i64,
    leaf : bool,
    t : u8, 


    pub fn new() Self {
        return Self{
            .child_ptr = undefined,
            .has_number = 0,
            .element = undefined,
            .leaf = true,
            .t = 4
        };
    }

    pub fn allocNode() Self {
        var node = Btree.new();
        node.child_ptr  =  &[4]*Btree{&Btree.new(), &Btree.new(), &Btree.new(), &Btree.new()};
        node.element = &[3]i64{undefined, undefined, undefined};
        return node;
    }
  
    pub fn splitChild(x : Btree, insert_element : i64) void{
    }

    pub fn insertNonFull(x : *Btree, insert_element : i64) void {
        var i = x.has_number;
        if(x.leaf){
            while(i >= 1 and insert_element < x.element[i]) : ( i -= 1 ) {
                x.element[i + 1] = x.element[i];
                i -= 1;
            }
        } else {
            while(i >= 1 and insert_element < x.element[i]) : ( i -= 1 ) {}
            i += 1;
            var y = x.child_ptr[i];
            if(y.child_ptr[i].has_number == 2*x.t - 1){
                splitChild(y.*, i);
                if (insert_element > y.element[i]){
                    i += 1; 
                }
            }
            insertNonFull(y.child_ptr[i], insert_element);
        }

    }

    pub fn insert(self : Self, insert_element : i64, root : *Btree) void {
        var r = root;
        if(root.has_number == 2*root.t - 1){ //最大7キー入るノードだから
            var s = allocNode();
            s.leaf = false;
            s.child_ptr[0] = r;
            splitChild(s, 1);
            insertNonFull(&s, insert_element);
        } else {
            insertNonFull(r, insert_element);
        }

    }
};

pub fn main() anyerror!void {
    var root = Btree.allocNode(); // create root
    root.insert(1, &root);
}
